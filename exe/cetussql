#!/usr/bin/env ruby
# ----------------------------------------------------------------------------- #
#         File: cetusql
#  Description: Fast database navigator for sqlite
#       Author: rkumar
#         Date: 2013-02-17 - 17:48
#      License: GPL
#  Last update: 2017-03-27 16:58
# ----------------------------------------------------------------------------- #
#  cetussql  Copyright (C) 2012-2017 rahul kumar
#  == TODO
#  + view_schema
#  - make_query
#  - menu keeps repeating don't show, can press ENTER or ` to view it
#  - the menus and hotkeys suck , need to be fixed.
#  - 
#  - store history in another file, per database, not one file, getting too large.
#  + order by is stored, so picked up against wrong database
#  + if headers requested then we have to add them.
#   last_sql must be for current database not just any. save under this database and retrieve under this database
#   - up arrow on table menu should call edit_last_sql
#   ? don't redraw the menu. the loop is outside the menu. keep it inside menu() so that it is not redrawn
#    but exits upon q. what if user does not want that ?
#
#   options : unformatted with tabs output - huge outputs take time
#      STDOUT or file. specify output to a file
#      header off and on
#
#
#  == END TODO
require 'readline'
require 'io/wait' # may not need this
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
require 'yaml'
#require 'fileutils'
# in ~/work/projects/common/
require 'cetusql/cli_utils'
require 'cetusql/cli_sqlite'
# -- requires 1.9.3 or higher for io/wait
# -- cannot do with Highline since we need a timeout on wait, not sure if HL can do that

VERSION="0.0.2"
O_CONFIG=true
CONFIG_FILE=File.expand_path("~/.cetusqlinfo")
# Using this to store data that has to be used in actions which do not take parameters or return values
#  when called from a key
$options = {}
$options[:headers] = true
$options[:output_to] = nil
$options[:formatting] = true

$bindings = {}
$bindings = {
  "`"   => "main_menu",
  "="   => "toggle_menu",
  "!"   => "command_mode",
  "@"   => "selection_mode_toggle",
  "M-a" => "select_all",
  "M-A" => "unselect_all",
  ","   => "goto_parent_dir",
  "+"   => "goto_dir",
  "."   => "pop_dir",
  ":"   => "subcommand",
  "'"   => "goto_bookmark",
  "/"   => "enter_regex",
  "M-p"   => "prev_page",
  "M-n"   => "next_page",
  "SPACE"   => "next_page",
  "M-f"   => "select_visited_files",
  "M-d"   => "select_used_dirs",
  "M-b"   => "select_bookmarks",
  "M-m"   => "create_bookmark",
  "M-M"   => "show_marks",
  "C-c"   => "escape",
  "ESCAPE"   => "escape",
  "TAB"   => "views",
  "C-i"   => "views",
  "?"   => "dirtree",
  "ENTER"   => "select_current",
  "D"   => "delete_file",
  "M"   => "file_actions most",
  "Q"   => "quit_command",
  "RIGHT"   => "column_next",
  "LEFT"   => "column_next 1",
  "C-x"   => "file_actions",
  "M--"   => "columns_incdec -1",
  "M-+"   => "columns_incdec 1",
  "S"     =>  "command_file list y ls -lh",
  "L"     =>  "command_file Page n less",
  "C-d"   =>  "cursor_scroll_dn",
  "C-b"   =>  "cursor_scroll_up",
  "UP"   =>  "cursor_up",
  "DOWN"   =>  "cursor_dn",
  "C-SPACE" => "visual_mode_toggle",

  "M-?"   => "print_help",
  "F1"   => "print_help",
  "F2"   => "child_dirs",
  "F3"   => "dirtree",
  "F4"   => "tree",
  "S-F1"   => "dirtree",
  "S-F2"   => "tree"

}



$selected_files = Array.new
$bookmarks = {}
$mode = nil
$glines=%x(tput lines).to_i
$gcols=%x(tput cols).to_i
$grows = $glines - 3
$pagesize = 60
$gviscols = 3
$pagesize = $grows * $gviscols
$stact = 0
$editor_mode = true
MSCROLL = 10
$patt=nil
$quitting = false
$modified = $writing = false
## dir stack for popping
## dirs where some work has been done, for saving and restoring
$used_dirs = []
$viewctr = 0
$history = []
$sta = $cursor = 0
$visual_mode = false

$help = "#{BOLD}M-?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}!#{BOLD_OFF} Command   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}@#{BOLD_OFF} Selection Mode  #{BOLD}Q#{BOLD_OFF} Quit "

  ## main loop which calls all other programs
  db = nil
def run()
  ctr=0
  filename, db, tables = change_database ARGV[0]
  #filename = ARGV[0] || getdbname
  #if filename
    #db = Database.new filename
    #tables = db.tables
  #end
  exit unless db
  #$mode = $current_db
  # TODO populate readline with earlier SQLS for this database
  prompt = ""
  

  while true
    i = 0
    #system("clear")
    # title
    filename = $g_data[:filename]
    db = $g_data[:db]
    print "#{GREEN}#{$help}  #{BLUE}cetusql #{VERSION}#{CLEAR}\n"
    #t = "#{$title}"
    #t = t[t.size-$gcols..-1] if t.size >= $gcols
    #print "#{BOLD}#{t}#{CLEAR}\n"
    # another query , change table, save sql, change db, select multiple tables
    # schema, count, sample
    # ZZZ XXX
    #print "\r#{_mm}#{$patt} >"
    ch, text = db_menu
    puts ch if $opt_debug
    # TODO all this should not be here
    chi = ch.to_i
    if chi > 0 and chi < 10
      tables = fetch(:tables)
      tablename = tables[chi - 1]
      if tablename
        #puts "selected   #{tables[chi]}  "
        select_table(tablename)
      end
    end
    # TODO if number is < 10 then see if there's a table and select that table
    #puts
    break if ch == "q" or ch == "ESCAPE" or ch == "C-c"
    next
  end
  puts "bye"
  $writing = true
  config_write if $writing
end
def config_write
  $g_data[:db] = nil
  $g_data[:tables] = nil
  writeYML $g_data, CONFIG_FILE
end
def config_read
  if File.exist? CONFIG_FILE
    $g_data = loadYML(CONFIG_FILE)
  else
    $g_data = {}
  end
end

def loadYML( filename)
  hash = YAML::load( File.open( filename ) )
  #puts hash.keys.size
  return hash
end

require 'fileutils' # for mkdir_p
def writeYML obj, filename
  dir = File.dirname filename
  unless File.exist? dir
    FileUtils::mkdir_p dir
  end
  File.open(filename, 'w') {|f| f.write obj.to_yaml }
  #$stderr.puts color("==> written to #{filename}", "green", "bold") unless $opt_quiet
  $stderr.puts("==> written to #{filename}") unless $opt_quiet
end


def db_menu
  h = {
    :t => :select_table,
    :s => :save_sql,
    :h => :sql_history,  # databases accessed, tables accessed, sqls issued
    :m => :multi_select_table,
    :l => :list_tables,
    :e => :edit_last_sql,
    :O => :output_to,
    :F => :formatting_toggle,
    :d => :change_database,
    "UP" => :edit_last_sql,
    :q => :quit
  }
  menu "DB Menu for #{current_dbname}", h
end
def table_menu tablename=nil
  t = tablename || current_tablename()
  h = {
    "2".to_sym => :view_all_rows,
    "3".to_sym => :view_sample,
    "9".to_sym => :view_recent,
    "4".to_sym => :select_columns,
    "5".to_sym => :select_orderby,
    "6".to_sym => :select_where,
    "R".to_sym => :run_query,
    "0".to_sym => :make_query, # TODO
    :s => :save_sql,
    :x => :new_query, # DDL no result enter a query and execute
    :h => :history_menu,  # queries for this table
    :c => :view_schema, 
    :e => :edit_last_sql,
    :O => :output_to,
    :d => :change_database,
    "UP" => :edit_last_sql,
    :q => :quit
  }
  menu "Table Menu for #{t}", h
end

# TODO
def make_query tablename=nil
  # 1. select table if nil
  # 2 select columns for display
  # 3. select order
  # 4. select where
  # 5. select LIMIT
  # 6. edit and run

end
def new_query
  db = current_db()
  tablename = current_tablename()
  columns = db.columns(tablename)
  #sql = "SELECT #{columns.join(",")} FROM #{tablename} ;"
  sql = "SELECT\n#{columns.join(",\n")} \nFROM #{tablename} \nLIMIT 1000\n ;"
  puts "created sql" if $opt_debug
  edit_execute_in_editor sql
end
def edit_execute_in_editor sql
  require 'tempfile'
  tmpfile = Tempfile.new('SQL.XXXXXX')
  filename = tmpfile.path
  filename = Shellwords.escape(filename)
  tmpfile.write(sql)
  puts "written to #{filename}" if $opt_debug
  tmpfile.close
  mtime = File.mtime(filename)
  puts mtime if $opt_debug
  command = nil
  #system "vim #{filename}" and (command = File.open(filename).readlines.join(" ") )
  system "vim #{filename}" 
  mtime2 = File.mtime(filename)
  puts mtime2 if $opt_debug
  # we are comparing modification times of the file to see if user quit or saved.
  # vim returns a zero in both cases, unless user quits using :cq
  return if mtime2 == mtime
  #puts "not returnig"
  command = File.open(filename).readlines.join(" ") 
  if command
    command = command.gsub("\n", " ")
    #puts "got : #{command}" if command
    puts "..."
    view_sql command
  end
  set_last_sql command
end

def view_schema
  tablename = current_tablename
  pbold "Schema for #{tablename}"
  list_metadata tablename
  indexes_for_table tablename
  puts
end

def change_database filename=nil
  # add to g_data as visited_dbs
  filename = select_database_name unless filename
  if filename
    db = Database.new filename
    tables = db.tables
    $g_data[:filename] = filename
    $g_data[:db] = db
    #$g_data[:tables] = tables
    store(:tables, tables)
    $g_data[:visited_dbs] ||= []
    # TODO should be unique. remove if exists, then add
    $g_data[:visited_dbs].delete(filename)
    $g_data[:visited_dbs] << filename
    list_tables
    list_indexes
  end
  return filename, db, tables
end
# get database names
def select_database_name
  # Add recent ones, but remove directory portion if they belong to current dir
  choices = Dir['*.db','*.sqlite','*.sqlite3'] | $g_data[:visited_dbs].map {|e| e.sub(Dir.pwd + "/","") }
  if choices
    if choices.size == 1
      return File.expand_path(choices.first)
    else
      # select_from is in cli_utils.rb
      #db = select_from "Select database", choices
      #db = ctrlp choices
      db = choose choices
      return File.expand_path(db) if db
    end
  end 
  return nil
end
#alias :select_database_name :getdbname
def multi_select_table
  db = current_db
  sel_tables = multi_select "select tables ", db.tables
  columns = []
  sel_tables.each do |tablename|
    c = db.columns tablename
    c.each {|e| columns << "#{tablename}.#{e}" }
  end
  sel_columns = multi_select "select columns ", columns
  #puts sel_columns.size
  #puts sel_columns.class
  sel_columns ||= ['*']
  sql = "SELECT #{sel_columns.join(",")} FROM #{sel_tables.join(',')} \nWHERE\n LIMIT 1000\n ;"
  puts sql
  edit_execute_sql sql
  # TODO edit it and view result
  # TODO join based on commond fields, we have that code somewhere

end

# select a table and then immediately its columns
def select_table tablename=nil
  db = $g_data[:db]
  filename = $g_data[:filename]
  unless tablename
    tablename = select_from "Select table (#{filename})", db.tables
  end
  unless tablename
    if confirm("Do you wish to quit ? ")
      $quitting = true
      return false
    end
    return
  end
  $g_data[:current_tablename] = tablename
  list_metadata tablename
  indexes_for_table tablename
  ch = nil
  while ch != 'q'
    ch, text = table_menu tablename
  end
  #pause
  return true
end
# store some values against the current database
def store key, value
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][key] = value
  #$g_data[key] = value
end
# retrieve some values against the current database
def fetch key
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][key]
  #$g_data[key]
end
def select_columns
  puts "inside select_columns"
  db = current_db()
  tablename = current_tablename || puts("No table!!")
  columns = db.columns tablename
  # TODO
  # display columns with datatypes and indexes on them
  # count of rows
  # options for sample, first 100 rows last 100 rows (based on count)
  # option for selecting column, where, order, RUN, all_cols,
  sel_columns = multi_select "select column from #{tablename}", columns
  #puts sel_columns.size
  #puts sel_columns.class
  #p sel_columns
  sel_columns = ['*'] if sel_columns.size == 0
  # FIXME these should be stored against a specific database and table, otherwise they will cause
  #  errors
  store ':selected_columns', sel_columns
  puts fetch(':selected_columns')
  return true
end
def select_orderby
  db = current_db()
  tablename = current_tablename || exit
  columns = db.columns tablename
  sel_columns = multi_select "select order by from #{tablename}", columns
  sel_columns = nil if sel_columns.size == 0
  store ':order_by', sel_columns
  puts fetch(':order_by')
  return true
end
def select_where
  db = current_db()
  tablename = current_tablename || exit
  columns = db.columns tablename
  sel_columns = multi_select "select WHERE from #{tablename}", columns
  sel_columns = nil if sel_columns.size == 0
  a = []
  sel_columns.each do |e|
    s = input "WHERE #{e} "
    a << "#{e} #{s}"
  end
  store ':where', a.join(" AND ")
  puts fetch(':where')
  return true
end
def run_query
  t =  current_tablename
  c =  fetch(':selected_columns') || ['*']
  o =  fetch(':order_by') 
  w =  fetch(':where') 
  sql = "SELECT #{c.join(', ')} FROM #{t} "
  if w
    #sql += " WHERE #{w.join(', ')} "
    sql += " WHERE #{w} "
  end
  if o
    sql += " ORDER BY #{o.join(', ')} "
  end
  edit_execute_sql sql
  #sql = vared sql, "Edit SQL: "
  #return if sql.nil? or sql.size == 0
  #set_last_sql sql
  #view_sql sql
end
def edit_execute_sql sql
  command = vared sql, "Edit SQL:"
  if command.nil? or command.size == 0
    return false
  end
  puts "..."
  view_sql command
  set_last_sql command
  return true
end
def list_tables
  db = current_db()
  tables = current_db.tables
  data = [["#", "Table", "Rows", "Indexed"]]
  ctr = 1
  tables.each do |t|
    #columns, datatypes = db.get_metadata t
    content = db.get_data "SELECT count(1) from #{t} "
    rows = content.first.first
    indexed = '?'
    if $options[:index_info]
      indexed = db.indexed_columns(t) || "---"
    end
    char = ctr < 10 ? ctr.to_s : ""
    row = [char, t, rows, indexed]
    data << row
    ctr += 1
    #puts "#{t}  #{rows} "
  end
  view_array data
end
# I don't need to loop through tables SILLY !
# FIXME just loop without tables
def list_indexes
  db = current_db()
  data = [["Index", "Table", "Column/s"]]
  #columns, datatypes = db.get_metadata t
  sql = %Q{SELECT name, tbl_name, sql FROM sqlite_master WHERE type = "index" ORDER BY tbl_name }
  content = db.get_data sql
  return if content.nil? or content == []
  content.each do |r|
    if r[-1] != nil
      m = r[-1].match /\((.*)\)/
        r[-1] = m[1] if m
    end
    row = [ *r ]
    data << row
  end
  view_array data
end
def indexes_for_table t
  db = current_db()
  data = [["Index", "Table", "Column/s"]]
  sql = %Q{SELECT name, tbl_name, sql FROM sqlite_master WHERE type = "index" and tbl_name =  "#{t}" }
  content = db.get_data sql
  return if content.nil? or content == []
  content.each do |r|
    if r[-1] != nil
      m = r[-1].match /\((.*)\)/
        r[-1] = m[1] if m
    end
    row = [ *r ]
    data << row
  end
  view_array data
end
# if too long split and columnate at 10 rows
def list_metadata table
  db = current_db()
  columns, datatypes = db.get_metadata table
  array = []
  pbold "Table: #{table}"
    columns.each_with_index do |e, ix|
    #print "%-20s %s\n" % [e, datatypes[ix] ]
    array << "%-20s %s " % [e, datatypes[ix] ]
  end
  if false
  array = columnate array, $grows - 7
  array.each {|line| print line, "\n"  }
  end
  print_in_cols array, 3
  #array.to_table

end
def config
  $g_data[:databases][current_dbname()]
end
def sql_history
  dbc = config()
  hist = dbc[:history]
  saved = dbc[:saved_sqls]
  ctr = 1
  all = []
  if saved
    pbold "Saved sqls"
    saved.each_with_index {|e,i| puts "#{ctr} #{e}"; ctr += 1; }
    all += saved
  end
  if hist
    pbold "History"
    hist.each_with_index {|e,i| puts "#{ctr} #{e}"; ctr += 1; }
    all += hist
  end
  print "Select an sql: "
  choice = $stdin.gets.chomp
  puts choice
  return if choice == ""
  sql = all[choice.to_i - 1]
  return unless sql
  sql = vared sql, "Edit sql: "
  return if sql.nil? or sql.size == 0
  puts sql
  view_sql sql
end

# choose from an array. printed vertically no columns, choose number
def choose array, title=nil, prompt=': '

  pbold title if title
  array.each_with_index {|e,i| puts "#{i+1} #{e}" }
  while true
    print "> \r (Enter 1 to #{array.size}) "
    choice = $stdin.gets.chomp
    if choice == "" or choice == "q"
      return nil
    end
    chi = choice.to_i
    if chi < 1 or chi > array.size
      next
    end
    break
  end
  #puts choice
  return nil if choice == ""
  k = array[choice.to_i - 1]
  return k
end
  CSI = "\e["
def OLDchoose array, title=nil, prompt=': '

  # why is save and resutore not working heee
  $stdout.write "#{CSI}s"     # save cursor position
  while true
    pbold title if title
    array.each_with_index {|e,i| puts "#{i+1} #{e}" }
    print prompt
    choice = $stdin.gets.chomp
    chi = choice.to_i
    puts chi
    if choice == "" or choice == "q"
      return nil
    end
    if chi < 1 or chi > array.size
      puts "restore"
      $stdout.write "#{CSI}u"     # restore cursor position
      next
    end
    break
  end
    #puts choice
  return nil if choice == ""
  k = array[choice.to_i - 1]
  return k
end
  
def view_sql sql
  begin
    view_data current_db, sql, $options
  rescue => e  
    puts e.to_s
    puts e.message  
    #puts e.backtrace.join("\n")
  end  

end


# send output of following commands to this file
def output_to filename=nil
  unless filename
    filename = input "Enter output filename: "
    filename = filename.chomp
  end
  filename = nil if filename == ""
  $options[:output_to] = filename
  return filename
end
def formatting_toggle
  $options[:formatting] = !$options[:formatting]
  puts "Formatting is now #{$options[:formatting]}  "
  pause
end
def current_db
  $g_data[:db]
end
def current_dbname
  $g_data[:filename]
end
def current_tablename
  $g_data[:current_tablename]
end
# save an sql statement like a bookmark
# Would have liked to have a nickname for it, or title.
def save_sql sql=nil
  sql ||= $g_data[:last_sql] 
  $g_data[:databases] ||= {}
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][:saved_sqls] ||= []
  $g_data[:databases][current_dbname()][:saved_sqls].delete sql
  $g_data[:databases][current_dbname()][:saved_sqls] << sql
  $g_data[:databases][current_dbname()][:last_sql] = sql
  pgreen "Saved sql statement"
end
def set_last_sql sql
  $g_data[:last_sql] = sql
  # set history of sqls issued
  $g_data[:databases] ||= {}
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][:last_sql] = sql
  $g_data[:databases][current_dbname()][:history] ||= []
  $g_data[:databases][current_dbname()][:history].delete sql
  $g_data[:databases][current_dbname()][:history] << sql
end
def edit_last_sql
  # this can be buggy, if you change database
  #sql =  $g_data[:last_sql]
  sql = $g_data[:databases][current_dbname()][:last_sql]
  #edit_execute_sql sql
  edit_execute_in_editor sql
end
def view_array data
  filename = tabulate data, $options
  puts "Got  #{filename} " if $opt_verbose
  File.open(filename).readlines.each  {|line| puts line}
end
# display all rows of current table
def view_all_rows
  table = current_tablename()
  #set_last_sql sql
  sql = "SELECT * from #{table}"
  view_sql sql
end
def view_sample
  table = current_tablename()
  #set_last_sql sql
  sql = "SELECT * from #{table} LIMIT 100"
  view_sql sql
end
# view last 100 inserted rows
def view_recent
  table = current_tablename()
  sql = current_db().sql_recent_rows(table)
  view_sql sql
end
# uses fzf to select an old query
# fzf messes with quotes, so don't use
def history_menu

  dbc = config()
  array = []
  hist = dbc[:history] || []
  saved = dbc[:saved_sqls] || []
  array = saved | hist 
  unless array
    perror "No history for this database!"
    return false
  end
  #sql = single_select "Select query: ", array
  puts "Use up arrow to navigate queries, ^r to search:"
  command = editline array
  #command = vared sql, "Edit SQL:"
  if command.nil? or command.size == 0
    $quitting = true
    return false
  end
  view_sql command
  set_last_sql command
end


config_read
$g_data ||= {}

run 
