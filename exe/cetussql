#!/usr/bin/env ruby
# ----------------------------------------------------------------------------- #
#         File: cetusql
#  Description: Fast database navigator for sqlite
#       Author: rkumar
#         Date: 2013-02-17 - 17:48
#      License: GPL
#  Last update: 2017-03-21 20:21
# ----------------------------------------------------------------------------- #
#  cetussql  Copyright (C) 2012-2017 rahul kumar
#  == TODO
#
#  Earlier, db routines used global vars. We need to be able to switch between databases
#   and switch back. So state and history should be maintained across database files.
#
#   options : unformatted with tabs output
#      STDOUT or file. specify output to a file
#      header off and on
#
#
#  == END TODO
require 'readline'
require 'io/wait'
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
require 'yaml'
#require 'fileutils'
# in ~/work/projects/common/
require 'cetusql/cli_utils'
require 'cetusql/cli_sqlite'
# -- requires 1.9.3 or higher for io/wait
# -- cannot do with Highline since we need a timeout on wait, not sure if HL can do that

## INSTALLATION
# copy into PATH
# alias c=~/bin/cetusql
# c
VERSION="0.0.0"
O_CONFIG=true
CONFIG_FILE=File.expand_path("~/.cetusqlinfo")
# Using this to store data that has to be used in actions which do not take parameters or return values
#  when called from a key
$options = {}
$options[:headers] = "on"
$options[:output_to] = nil

$bindings = {}
$bindings = {
  "`"   => "main_menu",
  "="   => "toggle_menu",
  "!"   => "command_mode",
  "@"   => "selection_mode_toggle",
  "M-a" => "select_all",
  "M-A" => "unselect_all",
  ","   => "goto_parent_dir",
  "+"   => "goto_dir",
  "."   => "pop_dir",
  ":"   => "subcommand",
  "'"   => "goto_bookmark",
  "/"   => "enter_regex",
  "M-p"   => "prev_page",
  "M-n"   => "next_page",
  "SPACE"   => "next_page",
  "M-f"   => "select_visited_files",
  "M-d"   => "select_used_dirs",
  "M-b"   => "select_bookmarks",
  "M-m"   => "create_bookmark",
  "M-M"   => "show_marks",
  "C-c"   => "escape",
  "ESCAPE"   => "escape",
  "TAB"   => "views",
  "C-i"   => "views",
  "?"   => "dirtree",
  "ENTER"   => "select_current",
  "D"   => "delete_file",
  "M"   => "file_actions most",
  "Q"   => "quit_command",
  "RIGHT"   => "column_next",
  "LEFT"   => "column_next 1",
  "C-x"   => "file_actions",
  "M--"   => "columns_incdec -1",
  "M-+"   => "columns_incdec 1",
  "S"     =>  "command_file list y ls -lh",
  "L"     =>  "command_file Page n less",
  "C-d"   =>  "cursor_scroll_dn",
  "C-b"   =>  "cursor_scroll_up",
  "UP"   =>  "cursor_up",
  "DOWN"   =>  "cursor_dn",
  "C-SPACE" => "visual_mode_toggle",

  "M-?"   => "print_help",
  "F1"   => "print_help",
  "F2"   => "child_dirs",
  "F3"   => "dirtree",
  "F4"   => "tree",
  "S-F1"   => "dirtree",
  "S-F2"   => "tree"

}



$selected_files = Array.new
$bookmarks = {}
$mode = nil
$glines=%x(tput lines).to_i
$gcols=%x(tput cols).to_i
$grows = $glines - 3
$pagesize = 60
$gviscols = 3
$pagesize = $grows * $gviscols
$stact = 0
$editor_mode = true
MSCROLL = 10
$patt=nil
$quitting = false
$modified = $writing = false
## dir stack for popping
## dirs where some work has been done, for saving and restoring
$used_dirs = []
$viewctr = 0
$history = []
$sta = $cursor = 0
$visual_mode = false

$help = "#{BOLD}M-?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}!#{BOLD_OFF} Command   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}@#{BOLD_OFF} Selection Mode  #{BOLD}Q#{BOLD_OFF} Quit "

  ## main loop which calls all other programs
  db = nil
def run()
  ctr=0
  filename, db, tables = change_database ARGV[0]
  #filename = ARGV[0] || getdbname
  #if filename
    #db = Database.new filename
    #tables = db.tables
  #end
  exit unless db
  #$mode = $current_db
  # TODO populate readline with earlier SQLS for this database
  prompt = ""
  

  while true
    i = 0
    #system("clear")
    # title
    filename = $g_data[:filename]
    db = $g_data[:db]
    print "#{GREEN}#{$help}  #{BLUE}cetusql #{VERSION}#{CLEAR}\n"
    t = "#{$title}"
    t = t[t.size-$gcols..-1] if t.size >= $gcols
    #print "#{BOLD}#{t}#{CLEAR}\n"
    # another query , change table, save sql, change db, select multiple tables
    # schema, count, sample
    # ZZZ XXX
    #print "\r#{_mm}#{$patt} >"
    ch, text = db_menu
    #puts
    break if ch == "q" or ch == "ESCAPE" or ch == "C-c"
    next
  end
  puts "bye"
  $writing = true
  config_write if $writing
end
def config_write
  $g_data[:db] = nil
  $g_data[:tables] = nil
  writeYML $g_data, CONFIG_FILE
end
def config_read
  if File.exist? CONFIG_FILE
    $g_data = loadYML(CONFIG_FILE)
  else
    $g_data = {}
  end
end

def loadYML( filename)
  hash = YAML::load( File.open( filename ) )
  #puts hash.keys.size
  return hash
end

require 'fileutils' # for mkdir_p
def writeYML obj, filename
  dir = File.dirname filename
  unless File.exist? dir
    FileUtils::mkdir_p dir
  end
  File.open(filename, 'w') {|f| f.write obj.to_yaml }
  #$stderr.puts color("==> written to #{filename}", "green", "bold") unless $opt_quiet
  $stderr.puts("==> written to #{filename}") unless $opt_quiet
end


def db_menu
  h = {
    "1".to_sym => :select_table,
    :s => :save_sql,
    :h => :history_menu,  # databases accessed, tables accessed, sqls issued
    :m => :multi_select_table,
    :l => :list_tables,
    :e => :edit_last_sql,
    :o => :output_to,
    :d => :change_database,
    :q => :quit
  }
  menu "DB Menu for #{current_dbname}", h
end


# MENU MAIN 
def main_menu
  raise 
  # TODO
  h = { 
    :a => :ack,
    "/" => :ffind,
    :l => :locate,
    :v => :viminfo,
    :z => :z_interface,
    :d => :child_dirs,
    :r => :recent_files,
    :t => :dirtree,
    "4" => :tree,
    :s => :sort_menu, 
    :F => :filter_menu,
    :c => :command_menu ,
    :B => :bindkey_ext_command,
    :M => :newdir,
    "%" => :newfile,
    :x => :extras
  }
  menu "Main Menu", h
end
def change_database filename=nil
  # add to g_data as visited_dbs
  filename = select_database_name unless filename
  if filename
    db = Database.new filename
    tables = db.tables
    $g_data[:filename] = filename
    $g_data[:db] = db
    $g_data[:tables] = tables
    $g_data[:visited_dbs] ||= []
    # TODO should be unique. remove if exists, then add
    $g_data[:visited_dbs] << filename
    list_tables
  end
  return filename, db, tables
end
def multi_select_table
  db = $g_data[:db]
  sel_tables = multi_select "select tables ", $g_data[:db].tables
  columns = []
  sel_tables.each do |tablename|
    c = db.columns tablename
    c.each {|e| columns << "#{tablename}.#{e}" }
  end
  sel_columns = multi_select "select columns ", columns
  #puts sel_columns.size
  #puts sel_columns.class
  sel_columns ||= ['*']
  sql = "SELECT #{sel_columns.join(",")} FROM #{sel_tables.join(',')} ;"
  puts sql
  perror "hit a key"
  # TODO edit it and view result
  # TODO join based on commond fields, we have that code somewhere

end

def select_table
  db = $g_data[:db]
  filename = $g_data[:filename]
  tablename = select_from "Select table (#{filename})", db.tables
  unless tablename
    if confirm("Do you wish to quit ? ")
      $quitting = true
      return false
    end
    return
  end
  columns = db.columns tablename
  sel_columns = multi_select "select column from #{tablename}", columns
  #puts sel_columns.size
  #puts sel_columns.class
  sel_columns ||= ['*']
  sql = "SELECT #{sel_columns.join(",")} FROM #{tablename} ;"
  #puts sql

  #Readline::HISTORY.push(sql) 
  #command = Readline::readline('>', true)
  command = vared sql, "Edit SQL:"
  if command.size == 0
    $quitting = true
    return false
  end
  view_data db, command, $options[:output_to]
  set_last_sql command
  return true
end
def list_tables
  db = current_db()
  tables = current_db.tables
  data = [["Table", "Rows"]]
  tables.each do |t|
    #columns, datatypes = db.get_metadata t
    content = db.get_data "SELECT count(1) from #{t} "
    rows = content.first.first
    row = [t, rows]
    data << row
    #puts "#{t}  #{rows} "
  end
  view_array data
end

# send output of following commands to this file
def output_to filename=nil
  unless filename
    filename = input "Enter output filename: "
    filename = filename.chomp
  end
  filename = nil if filename == ""
  $options[:output_to] = filename
  return filename
end
def current_db
  $g_data[:db]
end
def current_dbname
  $g_data[:filename]
end
def save_sql sql=nil
  sql ||= $g_data[:last_sql] 
  $g_data[:databases] ||= {}
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][:saved_sqls] ||= []
  $g_data[:databases][current_dbname()][:saved_sqls] << sql
end
def set_last_sql sql
  $g_data[:last_sql] = sql
  # set history of sqls issued
  $g_data[:databases] ||= {}
  $g_data[:databases][current_dbname()] ||= {}
  $g_data[:databases][current_dbname()][:history] ||= []
  $g_data[:databases][current_dbname()][:history] << sql
end
def edit_last_sql
  # this can be buggy, if you change database
  sql =  $g_data[:last_sql]
  command = vared sql, "Edit SQL:"
  if command.size == 0
    $quitting = true
    return false
  end
  view_data current_db, command, $options[:output_to]
  set_last_sql command
end
def view_array data
  filename = tabulate data
  puts "Got  #{filename} " if $opt_verbose
  File.open(filename).readlines.each  {|line| puts line}
end


config_read
$g_data ||= {}

run 
